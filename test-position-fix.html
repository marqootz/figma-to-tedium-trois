<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Position Calculation Fix Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f0f0f0;
    }
    
    .test-container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    
    .parent-frame {
      position: relative;
      width: 184px;
      height: 184px;
      background: #2c81a5;
      border-radius: 1000px;
      margin: 20px 0;
      overflow: hidden;
    }
    
    .frame-1316 {
      position: absolute;
      width: 155px;
      height: 184px;
      background: #2c81a5;
      border: 2px solid red;
    }
    
    .frame-1317 {
      position: absolute;
      width: 155px;
      height: 184px;
      background: transparent;
      border: 2px solid blue;
    }
    
    .svg-child {
      position: absolute;
      width: 123px;
      height: 52px;
      background: white;
      border: 1px dashed #999;
    }
    
    .label {
      position: absolute;
      top: -25px;
      left: 0;
      font-size: 12px;
      font-weight: bold;
    }
    
    .frame-1316 .label {
      color: red;
    }
    
    .frame-1317 .label {
      color: blue;
    }
    
    .position-info {
      font-size: 11px;
      color: #666;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <h1>Position and Layout Fix Test</h1>
  <p>This test demonstrates the fix for both layout hierarchy and CSS positioning issues.</p>
  
  <div class="test-container">
    <h2>Layout Hierarchy Issue</h2>
    <p>The problem was in the hierarchy of layout modes:</p>
    
    <div class="parent-frame">
      <div class="frame-1316" style="left: -75px; top: 0px;">
        <div class="label">Frame 1316 (VERTICAL layout)</div>
        <div class="svg-child" style="left: 16px; top: 131px;">SVG Child</div>
        <div class="position-info">Raw position: x=-75, y=0<br>Layout: VERTICAL, counterAxisAlignItems=MAX</div>
      </div>
      <div class="frame-1317" style="left: 99px; top: 0px;">
        <div class="label">Frame 1317 (VERTICAL layout)</div>
        <div class="svg-child" style="left: 15px; top: 0px;">SVG Child</div>
        <div class="position-info">Raw position: x=99, y=0<br>Layout: VERTICAL, counterAxisAlignItems=MIN</div>
      </div>
    </div>
    
    <h3>Hierarchy Structure:</h3>
    <ul>
      <li><strong>Parent:</strong> Frame with layoutMode="NONE" (no auto layout)</li>
      <li><strong>Children:</strong> Frames with layoutMode="VERTICAL" (auto layout)</li>
      <li><strong>Grandchildren:</strong> SVG elements positioned by auto layout</li>
    </ul>
    
    <h3>Problem:</h3>
    <p>The position calculation was only checking the parent's layout mode and ignoring the child's own layout properties. Since the parent had no auto layout, it was using the raw y=0 positions instead of calculating positions based on the children's layout properties.</p>
    
    <h3>Fixes Applied:</h3>
    <ul>
      <li><strong>Layout Hierarchy:</strong> calculateSelfLayoutPosition method checks node's own layout properties first</li>
      <li><strong>CSS Positioning:</strong> When parent has auto layout, children use position: relative (not absolute)</li>
      <li><strong>Auto Layout Detection:</strong> Only explicit layoutMode (HORIZONTAL/VERTICAL) triggers flex CSS generation</li>
      <li><strong>Flex CSS Generation:</strong> Apply display: flex only when layoutMode is explicitly set</li>
      <li><strong>Priority Order:</strong> Check node's own layout first, then parent's layout</li>
      <li><strong>Flex Layout:</strong> Children in flex containers flow naturally without explicit left/top positioning</li>
    </ul>
  </div>
  
  <div class="test-container">
    <h2>Expected Results</h2>
    <p>After the fix, the frames should be positioned correctly based on their own layout properties:</p>
    
    <h3>Frame 1316:</h3>
    <ul>
      <li><strong>Layout:</strong> VERTICAL with counterAxisAlignItems="MAX"</li>
      <li><strong>Expected:</strong> Positioned at the bottom of the parent container</li>
      <li><strong>Calculation:</strong> top = parentHeight - nodeHeight</li>
    </ul>
    
    <h3>Frame 1317:</h3>
    <ul>
      <li><strong>Layout:</strong> VERTICAL with counterAxisAlignItems="MIN"</li>
      <li><strong>Expected:</strong> Positioned at the top of the parent container</li>
      <li><strong>Calculation:</strong> top = 0</li>
    </ul>
    
    <h3>Technical Details:</h3>
    <pre>
// OLD CSS POSITIONING (incorrect)
// All children get position: absolute
properties.push(`position: absolute;`);
properties.push(`left: ${x}px;`);
properties.push(`top: ${y}px;`);

// NEW CSS POSITIONING (correct)
if (parentHasAutoLayout(parent)) {
  // Parent has auto layout - use relative positioning
  properties.push(`position: relative;`);
  // No left/top needed - flex handles positioning
} else {
  // Parent has no auto layout - use absolute positioning
  properties.push(`position: absolute;`);
  properties.push(`left: ${x}px;`);
  properties.push(`top: ${y}px;`);
}

// ENHANCED AUTO LAYOUT DETECTION
private parentHasAutoLayout(parent: FigmaNode): boolean {
  // Check explicit layout mode first
  if (parent.layoutMode && parent.layoutMode !== 'NONE') {
    return true;
  }
  
  // Check if parent has auto layout properties even if layoutMode is NONE
  // This handles cases where the Figma data is incorrect
  return parent.counterAxisAlignItems !== undefined ||
         parent.primaryAxisAlignItems !== undefined ||
         parent.itemSpacing !== undefined ||
         parent.paddingLeft !== undefined ||
         parent.paddingRight !== undefined ||
         parent.paddingTop !== undefined ||
         parent.paddingBottom !== undefined;
}

// FLEX CSS GENERATION
// OLD (incorrect)
if (node.layoutMode && node.layoutMode !== 'NONE') {
  properties.push(`display: flex;`);
  // Only explicit layoutMode triggered flex
}

// NEW (correct)  
if (nodeHasAutoLayout(node)) {
  properties.push(`display: flex;`);
  
  if (node.layoutMode === 'HORIZONTAL') {
    properties.push(`flex-direction: row;`);
  } else if (node.layoutMode === 'VERTICAL') {
    properties.push(`flex-direction: column;`);
  }
  
  // Apply alignment properties
  if (node.counterAxisAlignItems) {
    properties.push(`align-items: ${alignMap[node.counterAxisAlignItems]};`);
  }
  if (node.primaryAxisAlignItems) {
    properties.push(`justify-content: ${justifyMap[node.primaryAxisAlignItems]};`);
  }
  if (node.itemSpacing > 0) {
    properties.push(`gap: ${node.itemSpacing}px;`);
  }
}

// OLD LAYOUT HIERARCHY (incorrect)
if (parent.layoutMode !== 'NONE') {
  // Apply parent's layout properties
} else {
  // Use raw position
}

// NEW LAYOUT HIERARCHY (correct)
if (node.layoutMode !== 'NONE') {
  // Apply node's own layout properties first
  return calculateSelfLayoutPosition(node, parent);
} else if (parent.layoutMode !== 'NONE') {
  // Fall back to parent's layout properties
} else {
  // Use raw position
}
    </pre>
  </div>
</body>
</html>
