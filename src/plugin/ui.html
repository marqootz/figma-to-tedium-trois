<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
      line-height: 1.4;
      color: #333;
      background: #fff;
    }
    
    .container {
      padding: 16px;
    }
    
    .header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .header h1 {
      font-size: 16px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 4px;
    }
    
    .header p {
      color: #666;
      font-size: 11px;
    }
    
    .section {
      margin-bottom: 20px;
    }
    
    .section-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: #1a1a1a;
    }
    
    .button {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
      font-size: 12px;
      margin-bottom: 8px;
      transition: all 0.2s;
    }
    
    .button:hover {
      background: #f8f8f8;
      border-color: #ccc;
    }
    
    .button.primary {
      background: #0066cc;
      color: white;
      border-color: #0066cc;
    }
    
    .button.primary:hover {
      background: #0052a3;
    }
    
    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Status notifications removed */
    

    
    .output-area {
      margin-top: 16px;
      display: none;
    }
    
    .output-area textarea {
      width: 100%;
      height: 200px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 10px;
      resize: vertical;
    }
    
    .copy-button {
      margin-top: 8px;
    }
    
    .loading {
      display: none;
      text-align: center;
      padding: 20px;
      color: #666;
    }
    
    .loading::after {
      content: '';
      display: inline-block;
      width: 16px;
      height: 16px;
      margin-left: 8px;
      border: 2px solid #ddd;
      border-top-color: #0066cc;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Figma Animation Export</h1>
      <p>Export Figma animations to HTML</p>
    </div>
    
    <!-- Status notifications removed -->
    

    
    <div class="section">
      <div class="section-title">Export Options</div>
      <button id="export-both-btn" class="button primary">Export Both Files (Auto)</button>
      <div style="font-size: 10px; color: #666; margin-top: 6px; line-height: 1.3;">
        Downloads both files with automatic queue management
      </div>
      <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #eee;">
        <div style="font-size: 10px; color: #666; margin-bottom: 8px;">Individual Downloads:</div>
        <button id="export-json-btn" class="button" style="font-size: 11px; padding: 6px 10px;">Export Raw JSON</button>
        <button id="export-html-btn" class="button" style="font-size: 11px; padding: 6px 10px;">Export HTML Only</button>
      </div>
    </div>
    
    <div id="loading" class="loading">
      Processing...
    </div>
    

  </div>

  <script>
    // UI State
    // Removed currentHTML and currentJSON since we're downloading directly
    
    // DOM Elements
    const exportJsonBtn = document.getElementById('export-json-btn');
    const exportHtmlBtn = document.getElementById('export-html-btn');
    const exportBothBtn = document.getElementById('export-both-btn');
    const loadingEl = document.getElementById('loading');
    
    exportJsonBtn.addEventListener('click', () => {
      showLoading();
      parent.postMessage({ pluginMessage: { type: 'export-json' } }, '*');
    });
    
    exportHtmlBtn.addEventListener('click', () => {
      showLoading();
      parent.postMessage({ pluginMessage: { type: 'export-html' } }, '*');
    });
    
    exportBothBtn.addEventListener('click', () => {
      showLoading();
      parent.postMessage({ pluginMessage: { type: 'export-both' } }, '*');
    });
    

    
    // Message Handler
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;
      
      hideLoading();
      
      switch (msg.type) {
        case 'plugin-ready':
          console.log('Plugin ready - select components to export');
          break;
          
        case 'json-generated':
          handleJSONGenerated(msg);
          break;
          
        case 'html-generated':
          handleHTMLGenerated(msg);
          break;
          
        case 'both-generated':
          handleBothGenerated(msg);
          break;
          
        case 'error':
          console.error('Plugin error:', msg.message);
          break;
          
        default:
          console.log('Unknown message:', msg);
      }
    };
    
    // Helper Functions
    function showStatus(message, type = 'info') {
      // Notifications disabled
      return;
    }
    
    function showLoading() {
      loadingEl.style.display = 'block';
      exportJsonBtn.disabled = true;
      exportHtmlBtn.disabled = true;
      exportBothBtn.disabled = true;
    }
    
    function hideLoading() {
      loadingEl.style.display = 'none';
      exportJsonBtn.disabled = false;
      exportHtmlBtn.disabled = false;
      exportBothBtn.disabled = false;
    }
    
    function downloadFile(content, filename, contentType, suppressMessage = false) {
      return new Promise((resolve) => {
        const blob = new Blob([content], { type: contentType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        
        // Use a more aggressive approach - trigger download and wait longer
        a.click();
        
        // Clean up immediately
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);
        
        // Only show individual success message if not suppressed
        if (!suppressMessage) {
          showStatus(`Downloaded ${filename}`, 'success');
        }
        
        // Wait much longer to ensure the download dialog is handled
        console.log(`Download triggered for ${filename}, waiting 3 seconds...`);
        setTimeout(resolve, 3000);
      });
    }
    

    
    async function handleJSONGenerated(msg) {
      if (!msg.success) {
        console.error('JSON export failed:', msg.error || 'Unknown error');
        return;
      }
      
      // Use simple filename
      const filename = 'figma-export.json';
      
      // Download the JSON file directly
      await downloadFile(msg.json, filename, 'application/json');
      
      const metadata = msg.metadata || {};
      console.log(
        'JSON exported successfully! ' + 
        metadata.nodeCount + ' nodes, ' + 
        metadata.componentSets + ' component sets'
      );
    }
    
    async function handleHTMLGenerated(msg) {
      if (!msg.success) {
        console.error('HTML export failed:', msg.error || 'Unknown error');
        return;
      }
      
      // Use simple filename
      const filename = 'figma-export.html';
      
      // Download the HTML file directly
      await downloadFile(msg.html, filename, 'text/html');
      
      const metadata = msg.metadata || {};
      console.log(
        'HTML exported successfully! ' + 
        metadata.nodeCount + ' nodes, ' + 
        metadata.componentSets + ' component sets'
      );
    }
    
    // Download Queue Manager
    class DownloadQueue {
      constructor() {
        this.queue = [];
        this.isProcessing = false;
      }
      
      addToQueue(downloadTask) {
        this.queue.push(downloadTask);
        if (!this.isProcessing) {
          this.processQueue();
        }
      }
      
      async processQueue() {
        if (this.isProcessing || this.queue.length === 0) return;
        
        this.isProcessing = true;
        
        while (this.queue.length > 0) {
          const task = this.queue.shift();
          try {
            await task();
            // Wait much longer between downloads to ensure file dialog is handled
            if (this.queue.length > 0) {
              console.log('Waiting 5 seconds before next download...');
              await new Promise(resolve => setTimeout(resolve, 5000));
            }
          } catch (error) {
            console.error('Download task failed:', error);
          }
        }
        
        this.isProcessing = false;
      }
    }
    
    const downloadQueue = new DownloadQueue();
    
    async function handleBothGenerated(msg) {
      if (!msg.success) {
        console.error('Export failed:', msg.error || 'Unknown error');
        return;
      }
      
      const jsonFilename = 'figma-export.json';
      const htmlFilename = 'figma-export.html';
      
      console.log('Starting sequential download process...');
      console.log('IMPORTANT: Please handle each file dialog when it appears!');
      
      try {
        // Download JSON first with longer wait
        console.log('Step 1: Downloading JSON file...');
        await downloadFile(msg.json, jsonFilename, 'application/json', true);
        console.log('JSON download initiated. Please save the file when prompted.');
        
        // Wait for user to handle the dialog
        console.log('Waiting 8 seconds for JSON dialog to be handled...');
        await new Promise(resolve => setTimeout(resolve, 8000));
        
        // Download HTML second
        console.log('Step 2: Downloading HTML file...');
        await downloadFile(msg.html, htmlFilename, 'text/html', true);
        console.log('HTML download initiated. Please save the file when prompted.');
        
        // Log final success
        const metadata = msg.metadata || {};
        console.log(
          'Both files export process completed! ' + 
          '(' + metadata.nodeCount + ' nodes, ' + 
          metadata.componentSets + ' component sets)'
        );
        console.log('Check your downloads folder for both files.');
        
      } catch (error) {
        console.error('Error during download process:', error);
      }
    }
    
    function handleFileExported(msg) {
      if (!msg.success) {
        showStatus('File export failed: ' + (msg.error || 'Unknown error'), 'error');
        return;
      }
      
      // Create download link
      const blob = new Blob([msg.html], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = msg.filename || 'figma-export.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      const metadata = msg.metadata || {};
      showStatus(
        'File exported successfully! ' + 
        metadata.nodeCount + ' nodes exported to ' + a.download,
        'success'
      );
    }
  </script>
</body>
</html>
