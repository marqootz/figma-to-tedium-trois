<!doctype html><html><head><meta charset="utf-8"><style>* {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
      line-height: 1.4;
      color: #333;
      background: #fff;
    }
    
    .container {
      padding: 16px;
    }
    
    .header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .header h1 {
      font-size: 16px;
      font-weight: 600;
      color: #1a1a1a;
      margin-bottom: 4px;
    }
    
    .header p {
      color: #666;
      font-size: 11px;
    }
    
    .section {
      margin-bottom: 20px;
    }
    
    .section-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: #1a1a1a;
    }
    
    .button {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
      font-size: 12px;
      margin-bottom: 8px;
      transition: all 0.2s;
    }
    
    .button:hover {
      background: #f8f8f8;
      border-color: #ccc;
    }
    
    .button.primary {
      background: #0066cc;
      color: white;
      border-color: #0066cc;
    }
    
    .button.primary:hover {
      background: #0052a3;
    }
    
    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Status notifications removed */
    

    
    .output-area {
      margin-top: 16px;
      display: none;
    }
    
    .output-area textarea {
      width: 100%;
      height: 200px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 10px;
      resize: vertical;
    }
    
    .copy-button {
      margin-top: 8px;
    }
    
    .loading {
      display: none;
      text-align: center;
      padding: 20px;
      color: #666;
    }
    
    .loading::after {
      content: '';
      display: inline-block;
      width: 16px;
      height: 16px;
      margin-left: 8px;
      border: 2px solid #ddd;
      border-top-color: #0066cc;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }</style></head><body><div class="container"><div class="header"><h1>Figma Animation Export</h1><p>Export Figma animations to HTML</p></div><div class="section"><div class="section-title">Export Options</div><button id="export-both-btn" class="button primary">Export Both Files (Auto)</button><div style="font-size: 10px; color: #666; margin-top: 6px; line-height: 1.3;">Downloads both files with automatic queue management</div><div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #eee;"><div style="font-size: 10px; color: #666; margin-bottom: 8px;">Individual Downloads:</div><button id="export-json-btn" class="button" style="font-size: 11px; padding: 6px 10px;">Export Raw JSON</button> <button id="export-html-btn" class="button" style="font-size: 11px; padding: 6px 10px;">Export HTML Only</button></div></div><div id="loading" class="loading">Processing...</div></div><script>// UI State
    // Removed currentHTML and currentJSON since we're downloading directly
    
    // DOM Elements
    const exportJsonBtn = document.getElementById('export-json-btn');
    const exportHtmlBtn = document.getElementById('export-html-btn');
    const exportBothBtn = document.getElementById('export-both-btn');
    const loadingEl = document.getElementById('loading');
    
    exportJsonBtn.addEventListener('click', () => {
      showLoading();
      parent.postMessage({ pluginMessage: { type: 'export-json' } }, '*');
    });
    
    exportHtmlBtn.addEventListener('click', () => {
      showLoading();
      parent.postMessage({ pluginMessage: { type: 'export-html' } }, '*');
    });
    
    exportBothBtn.addEventListener('click', () => {
      showLoading();
      parent.postMessage({ pluginMessage: { type: 'export-both' } }, '*');
    });
    

    
    // Message Handler
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;
      
      hideLoading();
      
      switch (msg.type) {
        case 'plugin-ready':
          console.log('Plugin ready - select components to export');
          break;
          
        case 'json-generated':
          handleJSONGenerated(msg);
          break;
          
        case 'html-generated':
          handleHTMLGenerated(msg);
          break;
          
        case 'both-generated':
          handleBothGenerated(msg);
          break;
          
        case 'error':
          console.error('Plugin error:', msg.message);
          break;
          
        default:
          console.log('Unknown message:', msg);
      }
    };
    
    // Helper Functions
    function showStatus(message, type = 'info') {
      // Notifications disabled
      return;
    }
    
    function showLoading() {
      loadingEl.style.display = 'block';
      exportJsonBtn.disabled = true;
      exportHtmlBtn.disabled = true;
      exportBothBtn.disabled = true;
    }
    
    function hideLoading() {
      loadingEl.style.display = 'none';
      exportJsonBtn.disabled = false;
      exportHtmlBtn.disabled = false;
      exportBothBtn.disabled = false;
    }
    
    function downloadFile(content, filename, contentType, suppressMessage = false) {
      return new Promise((resolve) => {
        const blob = new Blob([content], { type: contentType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        
        // Use a more aggressive approach - trigger download and wait longer
        a.click();
        
        // Clean up immediately
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);
        
        // Only show individual success message if not suppressed
        if (!suppressMessage) {
          showStatus(`Downloaded ${filename}`, 'success');
        }
        
        // Wait much longer to ensure the download dialog is handled
        console.log(`Download triggered for ${filename}, waiting 3 seconds...`);
        setTimeout(resolve, 3000);
      });
    }
    

    
    async function handleJSONGenerated(msg) {
      if (!msg.success) {
        console.error('JSON export failed:', msg.error || 'Unknown error');
        return;
      }
      
      // Use simple filename
      const filename = 'figma-export.json';
      
      // Download the JSON file directly
      await downloadFile(msg.json, filename, 'application/json');
      
      const metadata = msg.metadata || {};
      console.log(
        'JSON exported successfully! ' + 
        metadata.nodeCount + ' nodes, ' + 
        metadata.componentSets + ' component sets'
      );
    }
    
    async function handleHTMLGenerated(msg) {
      if (!msg.success) {
        console.error('HTML export failed:', msg.error || 'Unknown error');
        return;
      }
      
      // Use simple filename
      const filename = 'figma-export.html';
      
      // Download the HTML file directly
      await downloadFile(msg.html, filename, 'text/html');
      
      const metadata = msg.metadata || {};
      console.log(
        'HTML exported successfully! ' + 
        metadata.nodeCount + ' nodes, ' + 
        metadata.componentSets + ' component sets'
      );
    }
    
    // Download Queue Manager - REMOVED (using direct sequential downloads instead)
    
    // Smart Dialog Detection System
    class DialogDetector {
      constructor() {
        this.isDialogOpen = false;
        this.dialogStartTime = 0;
        this.focusListeners = [];
      }
      
      startDialogDetection() {
        this.isDialogOpen = true;
        this.dialogStartTime = Date.now();
        
        // Method 1: Focus events
        const onFocus = () => {
          if (this.isDialogOpen) {
            console.log('Window regained focus - dialog likely closed');
            this.handleDialogClosed();
          }
        };
        
        const onBlur = () => {
          if (this.isDialogOpen) {
            console.log('Window lost focus - dialog opened');
          }
        };
        
        // Method 2: Visibility change
        const onVisibilityChange = () => {
          if (this.isDialogOpen && !document.hidden) {
            console.log('Page became visible - dialog likely closed');
            this.handleDialogClosed();
          }
        };
        
        // Method 3: User interaction detection
        const onUserInteraction = () => {
          if (this.isDialogOpen) {
            console.log('User interaction detected - dialog likely closed');
            this.handleDialogClosed();
          }
        };
        
        // Add event listeners
        window.addEventListener('focus', onFocus);
        window.addEventListener('blur', onBlur);
        document.addEventListener('visibilitychange', onVisibilityChange);
        document.addEventListener('click', onUserInteraction);
        document.addEventListener('keydown', onUserInteraction);
        
        // Store listeners for cleanup
        this.focusListeners = [
          () => window.removeEventListener('focus', onFocus),
          () => window.removeEventListener('blur', onBlur),
          () => document.removeEventListener('visibilitychange', onVisibilityChange),
          () => document.removeEventListener('click', onUserInteraction),
          () => document.removeEventListener('keydown', onUserInteraction)
        ];
        
        // Fallback timer (shorter than before)
        this.fallbackTimer = setTimeout(() => {
          if (this.isDialogOpen) {
            console.log('Fallback timer triggered - proceeding with next download');
            this.handleDialogClosed();
          }
        }, 5000); // 5 seconds instead of 8
      }
      
      handleDialogClosed() {
        if (!this.isDialogOpen) return;
        
        this.isDialogOpen = false;
        clearTimeout(this.fallbackTimer);
        
        // Clean up event listeners
        this.focusListeners.forEach(cleanup => cleanup());
        this.focusListeners = [];
        
        const duration = Date.now() - this.dialogStartTime;
        console.log(`Dialog closed after ${duration}ms`);
        
        // Resolve the promise
        if (this.resolvePromise) {
          this.resolvePromise();
        }
      }
      
      waitForDialogClose() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
        });
      }
    }
    
    const dialogDetector = new DialogDetector();
    
    async function handleBothGenerated(msg) {
      if (!msg.success) {
        console.error('Export failed:', msg.error || 'Unknown error');
        return;
      }
      
      const jsonFilename = 'figma-export.json';
      const htmlFilename = 'figma-export.html';
      
      console.log('Starting smart sequential download process...');
      console.log('The system will detect when you finish with each file dialog!');
      
      try {
        // Download JSON first with smart detection
        console.log('Step 1: Downloading JSON file...');
        await downloadFile(msg.json, jsonFilename, 'application/json', true);
        console.log('JSON download initiated. Please save the file when prompted.');
        
        // Start dialog detection and wait for user
        dialogDetector.startDialogDetection();
        console.log('Waiting for you to handle the JSON dialog...');
        await dialogDetector.waitForDialogClose();
        console.log('JSON dialog handled!');
        
        // Download HTML second with smart detection
        console.log('Step 2: Downloading HTML file...');
        await downloadFile(msg.html, htmlFilename, 'text/html', true);
        console.log('HTML download initiated. Please save the file when prompted.');
        
        // Start dialog detection and wait for user
        dialogDetector.startDialogDetection();
        console.log('Waiting for you to handle the HTML dialog...');
        await dialogDetector.waitForDialogClose();
        console.log('HTML dialog handled!');
        
        // Log final success
        const metadata = msg.metadata || {};
        console.log(
          'Both files export process completed! ' + 
          '(' + metadata.nodeCount + ' nodes, ' + 
          metadata.componentSets + ' component sets)'
        );
        console.log('Check your downloads folder for both files.');
        
      } catch (error) {
        console.error('Error during download process:', error);
      }
    }
    
    function handleFileExported(msg) {
      if (!msg.success) {
        showStatus('File export failed: ' + (msg.error || 'Unknown error'), 'error');
        return;
      }
      
      // Create download link
      const blob = new Blob([msg.html], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = msg.filename || 'figma-export.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      const metadata = msg.metadata || {};
      showStatus(
        'File exported successfully! ' + 
        metadata.nodeCount + ' nodes exported to ' + a.download,
        'success'
      );
    }</script></body></html>